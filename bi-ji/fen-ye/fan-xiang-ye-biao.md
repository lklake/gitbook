# 反向页表

## 内容概括

正向页表与反向页表的实质区别在于，正向页表是对每个虚拟页，都保存其对应的物理页号，反向页表对每个物理页，都保存其对应的虚拟页号。由虚拟页号查物理页号时，在正向页表下，是将虚拟页号作为index去索引页表，从索引到的项中读出物理页号。而在反向页表下，需要拿着虚拟页号，和表中每一项进行对比，比对成功时的index为物理页号。

## 具体说明

页表是MMU需要的一种数据结构，MMU将CPU提供的虚拟地址转换为物理地址，用于访存。

页表就是保存虚拟地址到物理地址映射关系的数据结构。

我们把虚拟地址看作两部分，虚拟页号（vpn）与页内偏移量（offset）。物理地址同样分为两部分，物理页帧号（pfn）和页内偏移量（offset）。

### 正向页表

* 在常见的页表，即正向页表中，实现vpn到pfn映射的原理为，对每个vpn，都保存其对应的pfn，因此要建立一个项数为vpn个数的表，表内保存这个vpn的pfn（这里只考虑单级页表，因为多级页表只是一种优化，它没有改变正向页表原理）。因此这种做法的实质是将虚拟地址空间中的所有页都向物理地址空间中的页进行映射。另外，每个进程都有自己的虚拟地址空间，因此每个进程都需要拥有一个自己的正向页表。
* 查找时，取虚拟地址高位作为index索引正向页表，从索引得到的项中读取物理页号（或物理页起始地址）。

### 反向页表

![图1：反向页表示意图](../../.gitbook/assets/Screenshot\_20220113\_194852.png)

* 在反向页表中，实现vpn到pfn映射的原理为，对每个pfn，都保存其对应的vpn，因此要建立一个项数为pfn个数的表，表内保存这个pfn的vpn。另外由于每个进程都有自己的虚拟地址空间，因此在表项中，不仅要保存这个pfn的vpn，还要保存进程号（pid），表示这个vpn是哪一个进程的。这种做法的实质是将物理地址空间中的所有页都向虚拟地址空间中的页进行映射。
* 查找时，取虚拟地址高位作为虚拟页号，然后遍历反向页表的每一项，对比虚拟页号、进程号是否与表项匹配，匹配的表项的下标即为物理页号。由于遍历的方式效率低，因此会采用哈希等方式加速，但反向页表的原理不变。
